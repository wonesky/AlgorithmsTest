主要对象是重新排列数组元素的算法，其中每个元素都有一个主键。排序算法的目标就是将所有元素的主键按照某种方式排序。

时间方面：
对排序算法的研究时主要关注两点： **比较** 和 **交换**，对不交换元素的算法，那就看访问数组的次数。  

空间方面：
原地排序：除了函数调用所需的栈和固定数目变量之外无需额外内存
其他排序： 需要额外内存空间来存储另一份数组副本





## 初级排序算法

### 公用函数

```java
// public static boolean less(int a, int b){
//     return a < b? true:false;
// }
public static boolean less(Comparable v, Comparable w) {
    return v.compareTo(w) < 0;
}

// public static void exch(int[] a, int i, int j){
//     int temp = a[i];
//     a[i] = a[j];
//     a[j] = temp;
// }

public static void exch(Object[] a, int i, int j) {
    Object swap = a[i];
    a[i] = a[j];
    a[j] = swap;
}

// public static void show(int[] a) {
//     for (int i = 0; i < a.length; i++) {
//         System.out.print(a[i]+" ");
//     }
//     System.out.println("");
// }

public static void show(Comparable[] a) {
    for (int i = 0; i < a.length; i++) {
        System.out.print(a[i] + " ");
    }
    System.out.println("");
}

```


### 冒泡排序

```java

```

### 选择排序

```java
public static void sort(int[] a){
    int N = a.length;
    for(int i = 0; i < N; i++){
        int min = i;
        for(int j = i+1; j < N; j++){
            if(less(a[j], a[min])) min = j;
        }
        exch(a, i, min);
    }
}
```

### 插入排序

```java
public static void sort(Comparable[] a) {
    int N = a.length;
    for(int i = 1; i < N; i++){
        for(int j = i; j > 0 && less(a[j], a[j-1]); j--)
            exch(a, j, j-1);
    }
}
```

### 希尔排序

```java
public static void sort(Comparable[] a){
    int N = a.length;
    int h = 1;
    while(h < N/3) h = h * 3 + 1;
    while(h >= 1){
        for(int i = 1; i < N; i++){
            for(int j = i; j >= h && less(a[j],a[j-h]); j -= h)
                exch(a, j, j-h);
        }
        h = h / 3;
    }

}
```


## 归并排序

```java

private static void merge(Comparable[] a, int lo, int mid, int hi){
    int i = lo, j = mid +  1;
    //复制a[lo...hi]到aux[lo...hi]
    for(int k = lo; k <= hi; k++){
        aux[k] = a[k];
    }
    //归并回a[lo...hi]
    for(int k = lo; k <= hi; k++){
        if      (i > mid)              a[k] = aux[j++]; //左半边用尽取右半边元素
        else if (j > hi)               a[k] = aux[i++]; //右半边用尽取左半边元素
        else if (less(aux[i],aux[j]))  a[k] = aux[i++]; //左半边的当前元素小于右半边的当前元素，取左半边的
        else                           a[k] = aux[j++]; //右半边的当前元素小于左半边的当前元素，取右半边的
    }
}

private static void sort(Comparable[] a, int lo, int hi){
    if(hi <= lo) return;
    int mid = lo + (hi - lo)/2;
    sort(a, lo, mid); //左半边排序
    sort(a, mid+1, hi); //右半边排序
    merge(a, lo, mid, hi); //归并结果
}

private static Comparable[] aux; //归并排序辅助数组
public static void sort(Comparable[] a){
    aux = new Comparable[a.length]; //一次性分配空间
    sort(a, 0, a.length - 1);

}
```
- 自底向上归并排序

```java
//自底向上的归并排序  logN次两两归并
public static void sortBU(Comparable[] a){
    int N = a.length;
    aux = new Comparable[N];
    for(int sz = 1; sz < N; sz += sz){  //sz为子数组大小
        for(int lo = 0; lo < N - sz; lo += sz+sz){ //lo子数组索引
            merge(a,lo,lo+sz-1, Math.min(lo+sz+sz-1, N-1));
        }
    }
}
```

## 快速排序



## 堆排序
